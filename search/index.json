[{"content":"Vue3快速入门 环境安装 1 2 3 4 5 6 7 8 9 sudo apt install nodejs npm # 创建项目过程中需要输入项目名，其余选项都是 No nmp create vue@latest cd 项目名 npm install # 启动项目 npm run dev # 编译项目 npm run build 初始化环境 项目最初会有部分vue自带文件及样式，在项目名/src/ 目录找到并删除\n开发环境 推荐vscode，同时安装扩展volar\n入门教程推荐 vue官网文档适合速查，小白从零开始难以理解，这里我推荐：\nvue官方互动教程\n模板语法 文本插值 最基本的数据绑定形式是文本插值，采用\u0026quot;Mustache\u0026quot;语法(双大括号或双花括号)，会将数据解释为纯文本\n1 \u0026lt;span\u0026gt;Message: {{ msg }}\u0026lt;/span\u0026gt; 双括号标签会被替换为相应组件实例中msg属性的值，同时每次msg属性更改时他也会同步更新\n插入HTML v-html 指令，将元素的innerHTML与msg属性保持同步\n1 \u0026lt;p\u0026gt;Using v-html directive: \u0026lt;span v-html=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; 属性绑定 双大括号不能在HTML属性中使用，要响应式地绑定一个属性，应该使用 v-bind 指令，可以简写为 :id、:value、:title等\n1 \u0026lt;input :value=\u0026#34;msg\u0026#34;\u0026gt; 布尔型属性 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; const msg = ref(false) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :disabled=\u0026#34;msg\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style \u0026gt; \u0026lt;/style\u0026gt; 绑定多个动态值核心代码 通过不带参数的v-bind绑定\n1 2 3 4 5 6 7 const objectOfattrs = { id: \u0026#39;123\u0026#39;, class: \u0026#39;ak\u0026#39;, disabled: false, } \u0026lt;input v-bind=\u0026#34;objectOfattrs\u0026#34;\u0026gt; 改变时触发更新的状态被称为响应式 推荐使用ref() ref()可以接受任何值类型，会返回一个包裹对象，只有在.value属性下暴露内部值，才能进行输出和重新赋值\n在模板中ref返回的对象不需要使用.value，会被自动解包\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const message = ref(\u0026#34;Hello\u0026#34;) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;{{ message }} \u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; 对于响应式数组或原生集合类型中的元素被访问时，它不会被解包\n1 2 3 4 5 const books = ref([\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;]) const books1 = ref({id: \u0026#39;a\u0026#39;,id1: \u0026#39;b\u0026#39;,id3: \u0026#39;3\u0026#39;}) \u0026lt;p\u0026gt;{{ books[0] }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ books1.id }}\u0026lt;/p\u0026gt; reactive() 另一种声明响应式状态的方式，reactive使对象本身具有响应性\n1 const state = reactive({count : 0}) 计算属性核心代码 computed 依赖响应式状态的复杂逻辑，计算属性值会基于其响应式依赖被缓存，仅会在其响应式依赖更新时才会重新计算，而不用重复执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { reactive, computed } from \u0026#39;vue\u0026#39; const author = reactive({ name: \u0026#39;kk\u0026#39;, books: [ \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, ] }) const publishedBooksMessage = computed(()=\u0026gt;{ return author.books.length \u0026gt; 0 ? \u0026#39;yes\u0026#39; : \u0026#39;no\u0026#39; }) {{ publishedBooksMessage }} 事件监听 v-on指令监听DOM事件：通过修改ref更新组件状态\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script setup\u0026gt; import {ref} from \u0026#39;vue\u0026#39; const message = ref(\u0026#34;hello\u0026#34;) const number = ref(\u0026#34;1\u0026#34;) function increment() { message.value = \u0026#34;nihao\u0026#34; number.value++ } \u0026lt;/script\u0026gt; \u0026lt;button v-on:click=\u0026#34;increment\u0026#34;\u0026gt;{{ message }} {{number}}\u0026lt;/button\u0026gt; 简写：\n1 \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;{{ message }}\u0026lt;/button\u0026gt; 表单绑定 同时使用v-bind和v-on在表单的输入元素创建双向绑定，将输入框内容同步给相应的变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const text = ref(\u0026#34;\u0026#34;) function onInput(e) { // v-on 处理函数会接收原生 DOM 事件 // 作为其参数。 text.value = e.target.value } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input :value=\u0026#34;text\u0026#34; @input=\u0026#34;onInput\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ text }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; 简写：\n1 \u0026lt;input v-model=\u0026#34;display\u0026#34;\u0026gt; 条件渲染 v-if v-else v-else-if指令有条件的渲染元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const awesome = ref(true) function toggle() { awesome.value = false } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;toggle\u0026#34;\u0026gt;toggle\u0026lt;/button\u0026gt; \u0026lt;h1 v-if=\u0026#34;awesome\u0026#34;\u0026gt;Vue is awesome!\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; 列表渲染 v-for 指令渲染基于数组的列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; // 给每个 todo 对象一个唯一的 id let id = 0 const newTodo = ref(\u0026#39;\u0026#39;) const todos = ref([ { id: id++, text: \u0026#39;Learn HTML\u0026#39; }, { id: id++, text: \u0026#39;Learn JavaScript\u0026#39; }, { id: id++, text: \u0026#39;Learn Vue\u0026#39; } ]) function addTodo() { todos.value.push({ id: id++, text: newTodo.value }) newTodo.value = \u0026#39;\u0026#39; } function removeTodo(todo) { todos.value = todos.value.filter((t) =\u0026gt; t !== todo) } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;form @submit.prevent=\u0026#34;addTodo\u0026#34;\u0026gt; \u0026lt;input v-model=\u0026#34;newTodo\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Add Todo\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; :key=\u0026#34;todo.id\u0026#34;\u0026gt; {{ todo.text }} \u0026lt;button @click=\u0026#34;removeTodo(todo)\u0026#34;\u0026gt;X\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; 基础学得差不多转vue ui框架了，从0开始时学什么苦日子！！！！有需要建议直接查文档，此文档完结 ","date":"2024-02-18T09:03:53-05:00","permalink":"https://example.com/p/vue3%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"Vue3快速入门"},{"content":"迁移博客说明 最近在寻找实习，此前写的博客暂无精力总结改版，烦请见谅！\n","date":"2024-02-17T08:29:42-05:00","permalink":"https://example.com/p/%E8%BF%81%E7%A7%BB%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/","title":"迁移博客说明"},{"content":"安卓手机出厂自带诸多不必要软件,删除后可以优化手机内存占用空间降低功耗，但通过常规手段无法删除部分应用，所以要通过adb删除\ndebian系统安装adb命令\n1 sudo apt install adb centos系统安装adb命令\n1 sudo yum install adb 安装成功后，手机打开开发者设置(各品牌步骤不同，自行搜索)，找到允许adb调试选项\n然后电脑和手机通过数据线连接，命令行中输入adb命令，此时观察手机会出现是否允许adb调试选项，允许 接下来通过命令删除软件\n示例：\n1 2 3 4 5 adb shell pm uninstall -k --user 0 [软件包名] # 删除小米快应用服务框架 adb shell pm uninstall -k --user 0 com.miui.hybrid # 预装应用删除后恢复 adb shell cmd package install-existing [软件包名] 最大的难度是怎么知道软件包名？ 不知道软件包名就无法通过adb卸载，此时推荐开源软件apps_Packages info，没有联网功能还能显示所有软件包名，十分安全。\n可以通过f-droid.org官网下载，也可以点击此处下载\n警告 删除过程中建议谨慎操作，诸如服务框架之类的软件包名卸载后可能导致系统无法正常使用或无法开机，注意判别！操作前进行手机数据备份，避免误删某软件后数据消失\n","date":"2024-02-17T03:55:11-05:00","permalink":"https://example.com/p/%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/","title":"安卓手机内存优化"},{"content":"new和make的区别 new用于分配值类型(整数、浮点数、结构体等)的内存，并返回一个指向该类型零值的指针。 make用于创建切片、映射和通道等引用数据类型，并返回一个已经初始化后的实例。 他们的区别在于new只分配内存，并返回该类型的指针，但不会对该内存进行初始化，需要手动初始化比如\n1 2 m := new(map[string]int) m = make(map[string]int,5) 这些数据结构由于内部构造需要初始化，因此使用make用来初始化他们\n所有defer都会被执行吗 处于false分支的defer不会被执行\n多个defer执行顺序 defer归属函数即将返回时，延迟处理语句按defer逆序执行\nimport后面最后一个元素是包名吗 import指定的是包的路径标识符。包名是代码中使用的标识符，通过导入路径标识 符来确定\n类型断言语法 Interface.(Type)\n类型转换语法 Type(expression)\n为什么Cgo能调用C模块 因为C和Go二进制接口规范(ABI)具有兼容性\nGo语言取反操作 ^x，不支持~x 为什么delect只能用来删map func delete(m map[Type]Type1, key Type) ","date":"2024-02-17T03:52:30-05:00","permalink":"https://example.com/p/go%E8%A7%A3%E7%AD%94/","title":"Go解答"}]